<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>cocohelper.utils.segmentation &mdash; cocohelper  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/style.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/favicon_dark.png"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            cocohelper
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Reference:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apigen.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">cocohelper</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">cocohelper.utils.segmentation</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for cocohelper.utils.segmentation</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Utilities* for converting segmentation annotations between different formats.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">import</span> <span class="nn">numpy.typing</span> <span class="k">as</span> <span class="nn">npt</span>
<span class="kn">from</span> <span class="nn">pycocotools</span> <span class="kn">import</span> <span class="n">mask</span> <span class="k">as</span> <span class="n">coco_mask</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Polygon</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span><span class="p">,</span> <span class="n">ImageDraw</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">base64</span>
<span class="kn">import</span> <span class="nn">zlib</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">from</span> <span class="nn">cocohelper</span> <span class="kn">import</span> <span class="n">COCOHelper</span>


<div class="viewcode-block" id="MaskConverter"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.MaskConverter.html#cocohelper.utils.segmentation.MaskConverter">[docs]</a><span class="k">class</span> <span class="nc">MaskConverter</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<div class="viewcode-block" id="MaskConverter.encode"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.MaskConverter.html#cocohelper.utils.segmentation.MaskConverter.encode">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="MaskConverter.decode"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.MaskConverter.html#cocohelper.utils.segmentation.MaskConverter.decode">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="RLEMaskConverter"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.RLEMaskConverter.html#cocohelper.utils.segmentation.RLEMaskConverter">[docs]</a><span class="k">class</span> <span class="nc">RLEMaskConverter</span><span class="p">(</span><span class="n">MaskConverter</span><span class="p">):</span>
<div class="viewcode-block" id="RLEMaskConverter.encode"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.RLEMaskConverter.html#cocohelper.utils.segmentation.RLEMaskConverter.encode">[docs]</a>    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a binary mask to RLE encoding.</span>
<span class="sd">        Args:</span>
<span class="sd">            mask: a binary mask as a numpy array.</span>
<span class="sd">            **kwargs: extra parameters are ignored.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The RLE encoding of the binary mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">mask_to_rle</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="RLEMaskConverter.decode"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.RLEMaskConverter.html#cocohelper.utils.segmentation.RLEMaskConverter.decode">[docs]</a>    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts an RLE to a binary mask with the given output dtype.</span>
<span class="sd">        Args:</span>
<span class="sd">            code: RLE encoding of the semantic mask.</span>
<span class="sd">            **kwargs: extra parameters such as:</span>
<span class="sd">                - `dtype` to indicate the type of the output mask.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The RLE mask as a numpy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">rle_to_mask</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="CompressedRLEMaskConverter"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.CompressedRLEMaskConverter.html#cocohelper.utils.segmentation.CompressedRLEMaskConverter">[docs]</a><span class="k">class</span> <span class="nc">CompressedRLEMaskConverter</span><span class="p">(</span><span class="n">MaskConverter</span><span class="p">):</span>
<div class="viewcode-block" id="CompressedRLEMaskConverter.encode"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.CompressedRLEMaskConverter.html#cocohelper.utils.segmentation.CompressedRLEMaskConverter.encode">[docs]</a>    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a binary mask to compressed RLE format.</span>
<span class="sd">        Args:</span>
<span class="sd">            mask: a binary mask to encode.</span>
<span class="sd">            **kwargs: extra parameters are ignored.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A string encoding the mask as compressed RLE.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">mask_to_compressed_rle</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CompressedRLEMaskConverter.decode"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.CompressedRLEMaskConverter.html#cocohelper.utils.segmentation.CompressedRLEMaskConverter.decode">[docs]</a>    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a compressed RLE to a binary mask with the given output dtype.</span>
<span class="sd">        Args:</span>
<span class="sd">            code: RLE encoding of the semantic mask.</span>
<span class="sd">            **kwargs: extra parameters such as:</span>
<span class="sd">                - `height` and `width` to indicate the shape of the output mask.</span>
<span class="sd">                - `dtype` to indicate the type of the output mask.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The compressed RLE mask as a numpy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">compressed_rle_to_mask</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PolygonMaskConverter"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.PolygonMaskConverter.html#cocohelper.utils.segmentation.PolygonMaskConverter">[docs]</a><span class="k">class</span> <span class="nc">PolygonMaskConverter</span><span class="p">(</span><span class="n">MaskConverter</span><span class="p">):</span>
<div class="viewcode-block" id="PolygonMaskConverter.encode"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.PolygonMaskConverter.html#cocohelper.utils.segmentation.PolygonMaskConverter.encode">[docs]</a>    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts segmentation mask to a list of polygons.</span>
<span class="sd">        Args:</span>
<span class="sd">            mask: numpy array containing multiple segmentation masks. Each mask must</span>
<span class="sd">            **kwargs: extra parameters are ignored.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of polygons segmentation masks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">mask_to_polygon</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="PolygonMaskConverter.decode"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.PolygonMaskConverter.html#cocohelper.utils.segmentation.PolygonMaskConverter.decode">[docs]</a>    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates and returns a mask from polygon in COCO format.</span>
<span class="sd">        Args:</span>
<span class="sd">            code: polygon coordinates.</span>
<span class="sd">            **kwargs: extra parameters such as:</span>
<span class="sd">                - `width` and `height` to indicate the shape of the output mask.</span>
<span class="sd">                - `value` to indicate the value of the zero-valued pixels in the output mask.</span>
<span class="sd">                - `dtype` to indicate the type of the output mask.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The polygon mask as a numpy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">polygon_to_mask</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<span class="c1"># Mapping of segmentation modes to their respective converters</span>
<span class="n">MASK_CONVERTERS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;RLE&#39;</span><span class="p">:</span> <span class="n">RLEMaskConverter</span><span class="p">(),</span>
    <span class="s1">&#39;cRLE&#39;</span><span class="p">:</span> <span class="n">CompressedRLEMaskConverter</span><span class="p">(),</span>
    <span class="s1">&#39;polygon&#39;</span><span class="p">:</span> <span class="n">PolygonMaskConverter</span><span class="p">()</span>
<span class="p">}</span>


<div class="viewcode-block" id="encode_mask"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.encode_mask.html#cocohelper.utils.segmentation.encode_mask">[docs]</a><span class="k">def</span> <span class="nf">encode_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Encodes a mask using the specified</span>
<span class="sd">    Args:</span>
<span class="sd">        mask: a binary mask as a numpy array.</span>
<span class="sd">        mode: the mode to use for encoding the mask.</span>
<span class="sd">        **kwargs: extra parameters are ignored.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The encoded mask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">MASK_CONVERTERS</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="decode_mask"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.decode_mask.html#cocohelper.utils.segmentation.decode_mask">[docs]</a><span class="k">def</span> <span class="nf">decode_mask</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decodes a mask using the specified mode.</span>
<span class="sd">    Args:</span>
<span class="sd">        code: the encoded mask.</span>
<span class="sd">        mode: the mode to use for decoding the mask.</span>
<span class="sd">        **kwargs: extra parameters such as:</span>
<span class="sd">            - `height` and `width` to indicate the shape of the output mask (if mode in [cRLE, polygon]).</span>
<span class="sd">            - `value` to indicate the value of the zero-valued pixels in the output mask (if mode=polygon).</span>
<span class="sd">            - `dtype` to indicate the type of the output mask (if mode in [RLE, cRLE, polygon]).</span>

<span class="sd">    Returns:</span>
<span class="sd">        The decoded mask as a numpy array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">MASK_CONVERTERS</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="convert_to_mask"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.convert_to_mask.html#cocohelper.utils.segmentation.convert_to_mask">[docs]</a><span class="k">def</span> <span class="nf">convert_to_mask</span><span class="p">(</span><span class="n">segmentation</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a segmentation to a binary mask.</span>
<span class="sd">    Args:</span>
<span class="sd">        segmentation: the segmentation to convert.</span>
<span class="sd">        height: the height of the output mask.</span>
<span class="sd">        width: the width of the output mask.</span>
<span class="sd">        **kwargs: extra parameters</span>

<span class="sd">    Returns:</span>
<span class="sd">        The binary mask as a numpy array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">get_segmentation_mode</span><span class="p">(</span><span class="n">segmentation</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">decode_mask</span><span class="p">(</span><span class="n">segmentation</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="convert_to_mode"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.convert_to_mode.html#cocohelper.utils.segmentation.convert_to_mode">[docs]</a><span class="k">def</span> <span class="nf">convert_to_mode</span><span class="p">(</span><span class="n">segmentation</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a segmentation to the specified mode.</span>
<span class="sd">    Args:</span>
<span class="sd">        segmentation: the segmentation to convert.</span>
<span class="sd">        mode: the mode to convert the segmentation to.</span>
<span class="sd">        height: the height of the output mask.</span>
<span class="sd">        width: the width of the output mask.</span>
<span class="sd">        **kwargs: extra parameters</span>

<span class="sd">    Returns:</span>
<span class="sd">        The segmentation in the specified mode.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_mode</span> <span class="o">=</span> <span class="n">get_segmentation_mode</span><span class="p">(</span><span class="n">segmentation</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">curr_mode</span> <span class="o">==</span> <span class="n">mode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">segmentation</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">decode_mask</span><span class="p">(</span><span class="n">segmentation</span><span class="p">,</span> <span class="n">curr_mode</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">encode_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_segmentation_mode"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.get_segmentation_mode.html#cocohelper.utils.segmentation.get_segmentation_mode">[docs]</a><span class="k">def</span> <span class="nf">get_segmentation_mode</span><span class="p">(</span>
        <span class="n">segmentation</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">],</span> <span class="n">Dict</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Automatically detect the segmentation format: RLE, cRLE or polygon.</span>

<span class="sd">    The detection is based on the standard of coco format, where polygons</span>
<span class="sd">    are represented as lists, RLE as an object with size and counts properties,</span>
<span class="sd">    and cRLE as a string.</span>

<span class="sd">    Args:</span>
<span class="sd">        segmentation: the segmentation to inspect.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The segmentation mode as a string.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segmentation</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;polygon&#39;</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segmentation</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;RLE&#39;</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segmentation</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;cRLE&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid argument type for argument `segmentation`. &quot;</span>
                         <span class="s2">&quot;Input `segmentation` should have a list, dictionary, or string type.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mode</span></div>


<div class="viewcode-block" id="mask_to_rle"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.mask_to_rle.html#cocohelper.utils.segmentation.mask_to_rle">[docs]</a><span class="k">def</span> <span class="nf">mask_to_rle</span><span class="p">(</span>
        <span class="n">binary_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a binary mask to RLE encoding.</span>

<span class="sd">    Args:</span>
<span class="sd">        binary_mask: a binary mask as a numpy array.</span>
<span class="sd">        **kwargs: extra parameters are ignored.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The RLE encoding of the binary mask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">last_elem</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">running_length</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">binary_mask</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">last_elem</span><span class="p">:</span>
            <span class="n">counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">running_length</span><span class="p">)</span>
            <span class="n">running_length</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">last_elem</span> <span class="o">=</span> <span class="n">elem</span>
        <span class="n">running_length</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">running_length</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;counts&#39;</span><span class="p">:</span> <span class="n">counts</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">binary_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)}</span></div>


<div class="viewcode-block" id="rle_to_mask"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.rle_to_mask.html#cocohelper.utils.segmentation.rle_to_mask">[docs]</a><span class="k">def</span> <span class="nf">rle_to_mask</span><span class="p">(</span>
        <span class="n">rle_code</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">DTypeLike</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts an RLE to a binary mask with the given output dtype.</span>

<span class="sd">    Args:</span>
<span class="sd">        rle_code:</span>
<span class="sd">        dtype: an output dtype for the converted mask.</span>
<span class="sd">        **kwargs: extra parameters are ignored.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The RLE mask as a numpy array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">compressed_rle</span> <span class="o">=</span> <span class="n">coco_mask</span><span class="o">.</span><span class="n">frPyObjects</span><span class="p">(</span><span class="n">rle_code</span><span class="p">,</span> <span class="n">rle_code</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;size&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rle_code</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;size&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">binary_mask</span> <span class="o">=</span> <span class="n">coco_mask</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">compressed_rle</span><span class="p">)</span>
    <span class="n">binary_mask</span> <span class="o">=</span> <span class="n">binary_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">binary_mask</span></div>


<div class="viewcode-block" id="mask_to_compressed_rle"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.mask_to_compressed_rle.html#cocohelper.utils.segmentation.mask_to_compressed_rle">[docs]</a><span class="k">def</span> <span class="nf">mask_to_compressed_rle</span><span class="p">(</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a binary mask to compressed RLE format.</span>

<span class="sd">    Args:</span>
<span class="sd">        mask: a binary mask to encode.</span>
<span class="sd">        **kwargs: extra parameters are ignored.</span>
<span class="sd">    Returns:</span>
<span class="sd">        A string encoding the mask as compressed RLE.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># convert input mask to expected COCO API input --</span>
    <span class="n">mask_to_encode</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">mask_to_encode</span> <span class="o">=</span> <span class="n">mask_to_encode</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="n">mask_to_encode</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">mask_to_encode</span><span class="p">)</span>

    <span class="c1"># RLE encode mask --</span>
    <span class="n">encoded_mask</span> <span class="o">=</span> <span class="n">coco_mask</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">mask_to_encode</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;counts&quot;</span><span class="p">]</span>

    <span class="c1"># compress and base64 encoding --</span>
    <span class="n">binary_str</span> <span class="o">=</span> <span class="n">zlib</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">encoded_mask</span><span class="p">,</span> <span class="n">zlib</span><span class="o">.</span><span class="n">Z_BEST_COMPRESSION</span><span class="p">)</span>
    <span class="n">base64_str</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64encode</span><span class="p">(</span><span class="n">binary_str</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">base64_str</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span></div>


<div class="viewcode-block" id="compressed_rle_to_mask"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.compressed_rle_to_mask.html#cocohelper.utils.segmentation.compressed_rle_to_mask">[docs]</a><span class="k">def</span> <span class="nf">compressed_rle_to_mask</span><span class="p">(</span>
        <span class="n">rle_code</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">height</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
        <span class="n">width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">DTypeLike</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a compressed RLE to a binary mask with the given output dtype.</span>

<span class="sd">    Args:</span>
<span class="sd">        rle_code: RLE encoding of the semantic mask.</span>
<span class="sd">        width: width of the output image array.</span>
<span class="sd">        height: height of the output image array.</span>
<span class="sd">        dtype: an output dtype for the converted mask.</span>
<span class="sd">        **kwargs: extra parameters are ignored.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The compressed RLE mask as a numpy array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">decoded_string</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">rle_code</span><span class="p">)</span>
    <span class="n">uncompressed_string</span> <span class="o">=</span> <span class="n">zlib</span><span class="o">.</span><span class="n">decompress</span><span class="p">(</span><span class="n">decoded_string</span><span class="p">,</span> <span class="n">wbits</span><span class="o">=</span><span class="n">zlib</span><span class="o">.</span><span class="n">MAX_WBITS</span><span class="p">)</span>
    <span class="n">detection</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">],</span>
        <span class="s1">&#39;counts&#39;</span><span class="p">:</span> <span class="n">uncompressed_string</span>
    <span class="p">}</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">coco_mask</span><span class="o">.</span><span class="n">decode</span><span class="p">([</span><span class="n">detection</span><span class="p">])</span>
    <span class="n">binary_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">binary_mask</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="mask_to_polygon"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.mask_to_polygon.html#cocohelper.utils.segmentation.mask_to_polygon">[docs]</a><span class="k">def</span> <span class="nf">mask_to_polygon</span><span class="p">(</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">simplify_tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts segmentation mask to a list of polygons.</span>

<span class="sd">    To reduce the number of vertices in the obtained polygon, try to increase</span>
<span class="sd">    the value of `polygon_simplify_tolerance`.</span>

<span class="sd">    Args:</span>
<span class="sd">        mask: numpy array containing multiple segmentation masks. Each mask must</span>
<span class="sd">            be associated with a different number, where 0 is for background,</span>
<span class="sd">            and other numbers related to different objects. For example, objects</span>
<span class="sd">            of a class A may be associated with a value of 1, class B to values</span>
<span class="sd">            10, class C to 255, and so on.</span>
<span class="sd">        simplify_tolerance: a tolerance value used to remove redundant</span>
<span class="sd">            vertexes for the polygons extracted from the mask.</span>
<span class="sd">        **kwargs: extra parameters are ignored.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List of polygons segmentation masks.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">polygons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">classes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span>
        <span class="n">classes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># iterate over the different segmentations (classes) inside the mask:</span>
    <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span>
        <span class="c1"># pick the class-related segmentation and convert it to binary:</span>
        <span class="n">binary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">binary</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># compute mask contours and then convert them to polygons:</span>
        <span class="n">binary</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">contours</span><span class="p">,</span> <span class="n">hierarchy</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findContours</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">RETR_EXTERNAL</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">CHAIN_APPROX_SIMPLE</span><span class="p">)</span>

        <span class="c1"># simplify contours</span>
        <span class="n">contours</span> <span class="o">=</span> <span class="p">[</span><span class="n">cnt</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="k">for</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
            <span class="n">sqz_cnt</span> <span class="o">=</span> <span class="n">cnt</span>
            <span class="k">if</span> <span class="n">cnt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sqz_cnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">sqz_cnt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sqz_cnt</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># a polygon must contain at least 3 points</span>
                <span class="n">polygon</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">sqz_cnt</span><span class="p">)</span>
                <span class="n">polygon</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">tolerance</span><span class="o">=</span><span class="n">simplify_tolerance</span><span class="p">,</span> <span class="n">preserve_topology</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">polygon</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span>

                <span class="c1"># get coordinates</span>
                <span class="n">x_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">polygon</span><span class="p">]</span>
                <span class="n">y_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">polygon</span><span class="p">]</span>
                <span class="n">sgm</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span><span class="p">):</span>
                    <span class="n">sgm</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="p">)])</span>
                <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sgm</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">polygons</span></div>


<div class="viewcode-block" id="polygon_to_mask"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.polygon_to_mask.html#cocohelper.utils.segmentation.polygon_to_mask">[docs]</a><span class="k">def</span> <span class="nf">polygon_to_mask</span><span class="p">(</span>
        <span class="n">polygon_code</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">],</span>
        <span class="n">width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
        <span class="n">height</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">DTypeLike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates and returns a mask from polygon in COCO format.</span>

<span class="sd">    Args:</span>
<span class="sd">        polygon_code: polygon coordinates.</span>
<span class="sd">        width: width of the output image array.</span>
<span class="sd">        height: height of the output image array.</span>
<span class="sd">        value: a value used for substituting zero-valued pixels in the output</span>
<span class="sd">            numpy array.</span>
<span class="sd">        dtype: an output dtype for the converted mask.</span>
<span class="sd">        **kwargs: extra parameters are ignored.</span>


<span class="sd">    Returns:</span>
<span class="sd">        The polygon mask as a numpy array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># create a binary image</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># mode L = 8-bit pixels, black and white</span>
    <span class="n">draw</span> <span class="o">=</span> <span class="n">ImageDraw</span><span class="o">.</span><span class="n">Draw</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

    <span class="c1"># draw polygons</span>
    <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="n">polygon_code</span><span class="p">:</span>
        <span class="n">draw</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">outline</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># replace 0 with &#39;value&#39;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">return</span> <span class="n">mask</span></div>


<div class="viewcode-block" id="compute_polygon_area"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.compute_polygon_area.html#cocohelper.utils.segmentation.compute_polygon_area">[docs]</a><span class="k">def</span> <span class="nf">compute_polygon_area</span><span class="p">(</span>
        <span class="n">polygon</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes a segmentation area from its polygon coordinates.</span>

<span class="sd">    Args:</span>
<span class="sd">        polygon: polygon coordinates for the segmentation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The area of the segmentation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check we have the same number of x and y coordinates:</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">:</span>
        <span class="c1"># i.e. we have at least 3 points:</span>
        <span class="n">x_coords</span> <span class="o">=</span> <span class="n">polygon</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">y_coords</span> <span class="o">=</span> <span class="n">polygon</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">poly</span><span class="o">.</span><span class="n">area</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="coco_to_binary_masks"><a class="viewcode-back" href="../../../_autosummary/cocohelper.utils.segmentation.coco_to_binary_masks.html#cocohelper.utils.segmentation.coco_to_binary_masks">[docs]</a><span class="k">def</span> <span class="nf">coco_to_binary_masks</span><span class="p">(</span>
        <span class="n">ch</span><span class="p">:</span> <span class="n">COCOHelper</span><span class="p">,</span>
        <span class="n">dest_dir</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
        <span class="n">scaling</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts annotations from COCO to binary masks.</span>

<span class="sd">    Args:</span>
<span class="sd">        ch: a COCOHelper containing the source COCO dataset.</span>
<span class="sd">        dest_dir: a destination directory for the output (converted) files.</span>
<span class="sd">        scaling: an optional scaling parameter to rescale annotation values and</span>
<span class="sd">            improve their visibility by the human eye when opened with GUI tools.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None. Outputs the converted dataset in the given destination directory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dest_annotation_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">dest_dir</span><span class="p">)</span>
    <span class="n">dest_annotation_dir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">image_ids</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">imgs</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">img_id</span> <span class="ow">in</span> <span class="n">image_ids</span><span class="p">:</span>
        <span class="n">image_dict</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">filtered_imgs</span><span class="p">(</span><span class="n">img_ids</span><span class="o">=</span><span class="n">img_id</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="n">image_fname_prefix</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">image_dict</span><span class="p">[</span><span class="s2">&quot;file_name&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
        <span class="n">image_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">image_dict</span><span class="p">[</span><span class="s2">&quot;height&quot;</span><span class="p">],</span> <span class="n">image_dict</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">])</span>

        <span class="n">annotations</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">filtered_anns</span><span class="p">(</span><span class="n">img_ids</span><span class="o">=</span><span class="n">img_id</span><span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;records&#39;</span><span class="p">)</span>
        <span class="n">label_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">image_size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">annotations</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">convert_to_mask</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s2">&quot;segmentation&quot;</span><span class="p">],</span>
                                   <span class="n">height</span><span class="o">=</span><span class="n">image_dict</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">],</span>
                                   <span class="n">width</span><span class="o">=</span><span class="n">image_dict</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">])</span>
            <span class="n">label_mask</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s2">&quot;category_id&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">scaling</span>

            <span class="n">mask_filename</span> <span class="o">=</span> <span class="n">dest_annotation_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">image_fname_prefix</span><span class="si">}</span><span class="s1">_annotation.png&#39;</span>
            <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">mask_filename</span><span class="p">),</span> <span class="n">img</span><span class="o">=</span><span class="n">label_mask</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, AILAB-BH.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>